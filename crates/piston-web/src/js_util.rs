use js_sys::{Function, Object, Reflect};
use wasm_bindgen::{convert::FromWasmAbi, prelude::*};

/// Best-effort subclass check for two JS constructor functions.
///
/// Returns false if either `.prototype` lookup fails.
#[inline]
pub(crate) fn is_subclass(sub: &JsValue, sup: &JsValue) -> bool {
    // Must both be constructor functions
    if !sub.is_instance_of::<Function>() || !sup.is_instance_of::<Function>() {
        return false;
    }

    // Try to get sub.prototype; if that fails, bail out
    let sub_proto = match Reflect::get(sub, &JsValue::from_str("prototype")) {
        Ok(val) if !val.is_null() && !val.is_undefined() => val,
        _ => return false,
    };

    // Try to get sup.prototype; if that fails, bail out
    let sup_proto = match Reflect::get(sup, &JsValue::from_str("prototype")) {
        Ok(val) if !val.is_null() && !val.is_undefined() => val,
        _ => return false,
    };

    // Now test Object.prototype chain
    let sup_proto_obj: Object = sup_proto.unchecked_into();
    sup_proto_obj.is_prototype_of(&sub_proto)
}

// Adapted with minimal changes from
// https://github.com/wasmerio/wasmer/blob/641030b8d9414ac0ddd31500631d3cd863c1608f/lib/api/src/backend/js/error.rs#L101-L138
pub(crate) fn downcast_from_ptr<T: FromWasmAbi<Abi = u32>>(
    value: &JsValue,
    marker: &str,
    weak: bool,
) -> Option<T> {
    if !value.is_object() {
        return None;
    }

    let prototype = &Reflect::get_prototype_of(value).ok()?;
    let class = prototype.constructor();
    let key = JsValue::from_str(marker);

    let marker_func: Option<js_sys::Function> = Reflect::get(&class, &key)
        .and_then(|v: JsValue| v.dyn_into())
        .ok();

    marker_func.as_ref()?;

    // Safety: The marker function exists, therefore it's safe to convert back to T.
    unsafe {
        // Prefer cloning the JS wrapper if a `_clone()` method exists to avoid consuming
        // the original object (which would null out its internal pointer). This prevents
        // subsequent calls from seeing a null pointer when the same JS object is reused.
        let maybe_clone = Reflect::get(
            value,
            &JsValue::from_str(if weak { "_cloneWeak" } else { "_clone" }),
        )
        .ok()
        .and_then(|v| v.dyn_into::<js_sys::Function>().ok())
        .and_then(|clone_fn| clone_fn.call0(value).ok());

        // let target_obj = maybe_clone.as_ref().unwrap_or(value);
        let target_obj = maybe_clone.as_ref().expect("clone function returned null");

        // Note: this assumes the wrapper class generated by #[wasm_bindgen] will always have a
        // `__destroy_into_raw()` method which consumes the wrapper and returns a pointer.
        // This is valid as of wasm-bindgen version 0.2.100
        let destroy_key = JsValue::from_str("__destroy_into_raw");
        let ptr = Reflect::get(target_obj, &destroy_key)
            .ok()
            .and_then(|v| v.dyn_into::<js_sys::Function>().ok())
            .and_then(|destroy_into_raw| destroy_into_raw.call0(target_obj).ok())
            .and_then(|ret| ret.as_f64())?;

        Some(<T as wasm_bindgen::convert::FromWasmAbi>::from_abi(
            ptr as u32,
        ))
    }
}

// Adapter from
// https://github.com/RReverser/serde-wasm-bindgen/blob/eaee8643f4deaf3846fdafb1374708288e1def2f/src/lib.rs#L104C1-L187C2
pub mod try_from_js_value_preserve {
    use serde::{Deserialize, de::Error};
    use wasm_bindgen::{JsValue, convert::FromWasmAbi};

    // Some arbitrary string that no one will collide with unless they try.
    pub(crate) const PRESERVED_VALUE_MAGIC: &str = "1fc430ca-5b7f-4295-92de-33cf2b145d38";

    struct Magic;

    impl<'de> serde::de::Deserialize<'de> for Magic {
        fn deserialize<D: serde::de::Deserializer<'de>>(de: D) -> Result<Self, D::Error> {
            struct Visitor;

            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Magic;

                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("serde-wasm-bindgen's magic string")
                }

                fn visit_str<E: Error>(self, s: &str) -> Result<Self::Value, E> {
                    if s == PRESERVED_VALUE_MAGIC {
                        Ok(Magic)
                    } else {
                        Err(E::invalid_value(serde::de::Unexpected::Str(s), &self))
                    }
                }
            }

            de.deserialize_str(Visitor)
        }
    }

    // Intentionally asymmetrical wrapper to ensure that only serde-wasm-bindgen preserves roundtrip.
    #[derive(Deserialize)]
    #[serde(rename = "1fc430ca-5b7f-4295-92de-33cf2b145d38")]
    struct PreservedValueDeWrapper(Magic, Option<u32>);

    /// Deserialize any `JsCast` value.
    ///
    /// When used with the `Derializer` in `serde_wasm_bindgen`, this serializes the value by
    /// passing it through as a `JsValue` and casting it.
    ///
    /// This function is compatible with the `serde(deserialize_with)` derive annotation.
    pub fn deserialize<'de, D: serde::Deserializer<'de>, T: TryFrom<JsValue>>(
        de: D,
    ) -> Result<Option<T>, D::Error>
    where
        T::Error: std::fmt::Debug,
    {
        let wrap = PreservedValueDeWrapper::deserialize(de)?;
        // When used with our deserializer this unsafe is correct, because the
        // deserializer just converted a JsValue into_abi.
        //
        // Other deserializers are unlikely to end up here, thanks
        // to the asymmetry between PreservedValueSerWrapper and
        // PreservedValueDeWrapper. Even if some other deserializer ends up
        // here, this may be incorrect but it shouldn't be UB because JsValues
        // are represented using indices into a JS-side (i.e. bounds-checked)
        // array.
        wrap.1
            .map(|val| {
                let val: JsValue = unsafe { FromWasmAbi::from_abi(val) };
                val.try_into().map_err(|e| {
                    D::Error::custom(format_args!(
                        "incompatible JS value {e:?} for type {}",
                        std::any::type_name::<T>()
                    ))
                })
            })
            .transpose()
    }

    // No-op serializer
    pub fn serialize<S: serde::Serializer, T: TryInto<JsValue>>(
        _value: &Option<T>,
        serializer: S,
    ) -> Result<S::Ok, S::Error> {
        serializer.serialize_none()
    }
}

/// Treat a `JsValue` as an optional: returns `None` when the value is `undefined` or `null`,
/// otherwise returns `Some(value)`.
#[inline]
pub fn to_option(value: JsValue) -> Option<JsValue> {
    if value.is_undefined() || value.is_null() {
        None
    } else {
        Some(value)
    }
}
